################################################################################
#
# cross.cygclass - for building cross-compiled packages
#
# Part of cygport - Cygwin packaging application
# Copyright (C) 2006, 2008, 2010 Yaakov Selkowitz
# Provided by the Cygwin Ports project <http://sourceware.org/cygwinports/>
#
# cygport is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# cygport is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with cygport.  If not, see <http://www.gnu.org/licenses/>.
#
################################################################################

#****h* Cygclasses/cross.cygclass
#  SYNOPSIS
#  CROSS_HOST="..."
#  inherit cross
#  DESCRIPTION
#  This cygclass assists in "cross-compiling", where the code being built will
#  run on a different platform (the "host" system) then the one on which it was
#  built (and, in most cases, NOT on the build system), but can be used on the
#  build system to cross-compile other software which depends on it.
#
#  Supported build systems for cross-compiling are autotools, cmake, and custom
#  Makefiles.
#  SEE ALSO
#  toolchain.cygclass, canadian-cross.cygclass
#****

#****v* cross.cygclass/CROSS_HOST
#  DESCRIPTION
#  The CPU-VENDOR-OS triplet describing the system for which you are cross-compiling,
#  for example 'i686-pc-linux-gnu' or 'x86_64-w64-mingw32'.
#  NOTES
#  * CROSS_HOST must be defined before inherit()ing cross.cygclass.
#  * CROSS_HOST will be canonicalized upon calling "inherit cross".  That means
#    if set to 'amd64-linux', it will be changed into 'x86_64-pc-linux-gnu'.
#    Therefore it is important continue using $CROSS_HOST as a variable instead
#    of writing its initial value.
#****
if ! defined CROSS_HOST
then
	error "CROSS_HOST must be defined before 'inherit cross'"
fi

__cross_canonicalize_host() {
	local _tmp_host

	_tmp_host=$(${_privdatadir}/config.sub ${CROSS_HOST} 2> /dev/null)

	case x${_tmp_host} in
		*-*-none|x) error "Unknown or invalid CROSS_HOST declared: ${CROSS_HOST}" ;;
	esac

	CROSS_HOST=${_tmp_host}
	CHOST=${_tmp_host}
	CTARGET=${_tmp_host}
}


# set CHOST and CTARGET
__cross_canonicalize_host

#****d* cross.cygclass/CROSS_SYSROOT
#  DESCRIPTION
#  GCC cross-compilers provide the concept of a sysroot: a directory which
#  acts as the virtual root of the target filesystem, resulting in
#  CROSS_SYSROOT/$prefix/include and CROSS_SYSROOT/$prefix/lib being in the
#  default search paths without requiring -I or -L flags.
#
#  This means that software natively compiled for the host system can be
#  unpacked into the sysroot and used for cross-compiling.  This is
#  especially useful when bootstrapping a new toolchain; e.g. for Linux, one
#  can just download glibc and kernel headers packages from a Linux distro,
#  unpack them into the CROSS_SYSROOT, and use those to build a cross-GCC
#  for the first time.
#
#  If you do use natively-compiled host packages under the sysroot, you must
#  fix paths in all *-config scripts, .la libtool libraries, and .pc
#  pkg-config files so they do not erroneously point to Cygwin-native
#  headers and libraries.
#****
CROSS_SYSROOT="/usr/${CHOST}/sys-root"

#****o* cross.cygclass/CC (cross)
#  DESCRIPTION
#  The GCC C cross-compiler for the CROSS_HOST.
#****
CC="${CHOST}-gcc"

#****o* cross.cygclass/CXX (cross)
#  DESCRIPTION
#  The GCC C++ cross-compiler for the CROSS_HOST.
#****
CXX="${CHOST}-g++"

#****o* cross.cygclass/F77 (cross)
#  DESCRIPTION
#  The GCC Fortran 77 cross-compiler for the CROSS_HOST.
#****
F77="${CHOST}-gfortran"

#****o* cross.cygclass/FC (cross)
#  DESCRIPTION
#  The GCC Fortran 95 cross-compiler for the CROSS_HOST.
#****
FC="${CHOST}-gfortran"

#****o* cross.cygclass/GCJ (cross)
#  DESCRIPTION
#  The GCC Java cross-compiler for the CROSS_HOST.
#****
GCJ="${CHOST}-gcj"

case ${CHOST} in
*-pc-mingw*)
	# mingw.org packages are built to be compatible with MSVC-compiled software
	CFLAGS="${CFLAGS} -mms-bitfields"
	CXXFLAGS="${CXXFLAGS} -mms-bitfields"
	F77FLAGS="${F77FLAGS} -mms-bitfields"
	FCFLAGS="${FCFLAGS} -mms-bitfields"
	GCJFLAGS="${GCJFLAGS} -mms-bitfields"
	;;
esac

if ! check_prog ${CHOST}-gcc || ! check_prog ${CHOST}-objdump
then
	error "This package requires ${CHOST} binutils and gcc"
fi

export PKG_CONFIG_LIBDIR="$(__host_prefix)/lib/pkgconfig:/usr/share/pkgconfig"

#****I* cross.cygclass/doelflib
#  SYNOPSIS
#  doelflib libfoo.so.X.Y.Z [...]
#  DESCRIPTION
#  Installs the given ELF libraries into the CROSS_SYSROOT libdir and creates
#  the symlinks for the SONAME (usually .so.X) and the link library (.so).
#  NOTE
#  Only the real library file should be passed to doelflib, not the symlinks
#  usually created in the build directory.
#****
doelflib() {
	local clibdir="$(__host_prefix)/lib"
	local soname sonames

	dodir ${clibdir}

	for i
	do
		if [ ! -e ${i} ]
		then
			error "file ${i} does not exist"
		fi

		case ${i##*/} in
		*.so*)	;;
		*)	error "doelflib: ${i}: not an ELF shared object" ;;
		esac

		soname=$(${CHOST}-objdump -p ${i} | grep ' SONAME ' | sed -e 's| *SONAME *\([^ ]*\).*|\1|g')

		# try to catch mistaken "doelflib libfoo.so*"
		if echo "${sonames}" | grep -q ${soname}
		then
			error "SONAME ${soname} has already been installed"
		else
			sonames+=" ${soname} "
		fi

		__doinstall 0755 ${i} ${clibdir} || error "doelflib ${i} failed"

		if test ${i##*/} != ${soname}
		then
			dosym ${i##*/} ${clibdir}/${soname}
		fi
		if test ${soname%.so*}.so != ${soname}
		then
			dosym ${i##*/} ${clibdir}/${soname%.so*}.so
		fi
	done
}

readonly -f __cross_canonicalize_host doelflib
