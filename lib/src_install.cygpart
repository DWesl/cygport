################################################################################
#
# src_install.cygpart - cygport source installation functions
#
# Copyright (C) 2006, 2007, 2008, 2009, 2010 Yaakov Selkowitz
# Provided by the Cygwin Ports project <http://sourceware.org/cygwinports/>
#
# cygport is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# cygport is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with cygport.  If not, see <http://www.gnu.org/licenses/>.
#
################################################################################

#****I* Installing/dodir
#  SYNOPSIS
#  dodir DIRECTORY [DIRECTORY] ...
#  DESCRIPTION
#  Creates the given directories under $D.
#****
dodir() {
	local d;

	for d
	do
		if [ ! -d ${D}${d} ]
		then
			mkdir -p ${D}${d} || error "dodir ${d} failed"
		fi
	done
}

#****I* Installing/keepdir
#  SYNOPSIS
#  keepdir DIRECTORY [DIRECTORY] ...
#  DESCRIPTION
#  Preserves the given empty directories under $D from being removed during
#  automatic postinstall steps.
#****
keepdir() {
	for d
	do
		dodir ${d}
		touch ${D}${d}/.keep-${PN}
	done
}

__doinstall() {
	local mode=${1}
	local file=${2}
	local targetdir=${3}
	local targetfile=${4:-${2##*/}}
	local ltinst

	if [ ! -e ${file} ]
	then
		error "file ${file} does not exist"
		return 2
	fi

	if [ ! -d ${D}${targetdir} ]
	then
		error "Directory ${targetdir} does not exist"
		return 2
	fi

	ltinst=
	case ${file} in
		*.la)  ltinst="/usr/bin/libtool --mode=install" ;;
		*.exe) [ -f ${file%/*}/.libs/${file##*/} ] && ltinst="/usr/bin/libtool --mode=install" ;;
	esac

	verbose ${ltinst} /usr/bin/install -m${mode} ${file} ${D}${targetdir}/${targetfile}
	return $?
}


#****I* Installing/dobin
#  SYNOPSIS
#  dobin FILE [FILE] ...
#  DESCRIPTION
#  Installs the given file(s) to $D/usr/bin/ and makes them executable.
#****
dobin() {
	dodir /usr/bin

	for i
	do
		__doinstall 0755 ${i} /usr/bin || error "dobin ${i} failed"
	done
}

#****I* Installing/newbin
#  SYNOPSIS
#  newbin FILE NEW_NAME
#  DESCRIPTION
#  Installs the given file to $D/usr/bin/ with the given new name, and makes
#  it executable.
#****
newbin() {
	dodir /usr/bin
	__doinstall 0755 ${1} /usr/bin ${2} || error "newbin ${1} failed"
}


#****I* Installing/docinto
#  SYNOPSIS
#  docinto [/]SUBDIRECTORY
#  DESCRIPTION
#  Sets the subdirectory into which dodoc and newdoc should install.
#  If the subdirectory is prefixed by a slash, then dodoc and newdoc will use
#  /usr/share/doc/SUBDIRECTORY/; if not, they will use /usr/share/doc/PN/SUBDIRECTORY/.
#****
docinto() {
	if (( $# != 1 ))
	then
		error "docinto accepts exactly one argument";
	fi

	_docinto_dir=${1};
}

#****I* Installing/dodoc
#  SYNOPSIS
#  dodoc FILE [FILE] ...
#  DESCRIPTION
#  Installs the given files into $D/usr/share/doc/PN/, or a subdirectory thereof
#  specified by the previous call to docinto.
#****
dodoc() {
	case "${_docinto_dir}" in
		'')	docdir=/usr/share/doc/${PN} ;;
		/*)	docdir=/usr/share/doc${_docinto_dir} ;;
		*)	docdir=/usr/share/doc/${PN}/${_docinto_dir} ;;
	esac

	dodir ${docdir}

	for i
	do
		if [ -f ${i} -o -L ${i} ]
		then
			if [ "x$(file -b ${i})" != "xempty" -a ! -f ${D}${docdir}/${i} ]
			then
				__doinstall 0644 ${i} ${docdir} || error "dodoc ${i} failed"
			fi
		elif [ -f ${i}.txt -o -L ${i}.txt ]
		then
			if [ "x$(file -b ${i}.txt)" != "xempty" -a ! -f ${D}${docdir}/${i}.txt ]
			then
				__doinstall 0644 ${i}.txt ${docdir} || error "dodoc ${i}.txt failed"
			fi
		fi
	done
}

#****I* Installing/newdoc
#  SYNOPSIS
#  newdoc FILE NEW_NAME
#  DESCRIPTION
#  Installs the given file into $D/usr/share/doc/PN/, or a subdirectory thereof
#  specified by the previous call to docinto, with the given new name.
#****
newdoc() {
	case "${_docinto_dir}" in
		'')	docdir=/usr/share/doc/${PN} ;;
		/*)	docdir=/usr/share/doc${_docinto_dir} ;;
		*)	docdir=/usr/share/doc/${PN}/${_docinto_dir} ;;
	esac

	dodir ${docdir}
	__doinstall 0644 ${1} ${docdir} ${2} || error "newdoc ${1} failed"
}


#****I* Installing/exeinto
#  SYNOPSIS
#  exeinto DIRECTORY
#  DESCRIPTION
#  Specifies the directory under $D into which doexe and newexe will install.
#****
exeinto() {
	if (( $# != 1 ))
	then
		error "exeinto accepts exactly one argument";
	fi

	dodir ${1};
	_exeinto_dir=${1};
}

#****I* Installing/doexe
#  SYNOPSIS
#  doexe FILE [FILE] ...
#  DESCRIPTION
#  Installs the given file(s) into the directory under $D specified by the
#  preceding call to exeinto and makes them executable.
#****
doexe() {
	if ! defined _exeinto_dir || [ ! -d ${D}${_exeinto_dir} ]
	then
		error "exeinto must be called before doexe"
	fi

	for i
	do
		__doinstall 0755 ${i} ${_exeinto_dir} || error "doexe ${i} failed"
	done
}

#****I* Installing/newexe
#  SYNOPSIS
#  newexe FILE NEW_NAME
#  DESCRIPTION
#  Installs the given file into the directory under $D specified by the
#  preceding call to exeinto, renaming it as indicated, and makes it executable.
#****
newexe() {
	if ! defined _exeinto_dir || [ ! -d ${D}${_exeinto_dir} ]
	then
		error "exeinto must be called before doexe"
	fi

	__doinstall 0755 ${1} ${_exeinto_dir} ${2} || error "newexe ${1} failed"
}


#****I* Installing/insinto
#  SYNOPSIS
#  insinto DIRECTORY
#  DESCRIPTION
#  Specifies the directory under $D into which doins and newins will install.
#****
insinto() {
	if (( $# != 1 ))
	then
		error "insinto accepts exactly one argument";
	fi

	dodir ${1};
	_insinto_dir=${1};
}

#****I* Installing/doins
#  SYNOPSIS
#  doins FILE [FILE] ...
#  DESCRIPTION
#  Installs the given file(s) into the directory under $D specified by the
#  preceding call to insinto.  Files are made not executable.
#****
doins() {
	if ! defined _insinto_dir || [ ! -d ${D}${_insinto_dir} ]
	then
		error "insinto must be called before doins"
	fi

	for i
	do
		__doinstall 0644 ${i} ${_insinto_dir} || error "doins ${i} failed"
	done
}

#****I* Installing/newins
#  SYNOPSIS
#  newins FILE NEW_NAME
#  DESCRIPTION
#  Installs the given file into the directory under $D specified by the
#  preceding call to insinto, renaming it as indicated.  Files are made not
#  executable.
#****
newins() {
	if ! defined _insinto_dir || [ ! -d ${D}${_insinto_dir} ]
	then
		error "insinto must be called before doins"
	fi

	__doinstall 0644 ${1} ${_insinto_dir} ${2} || error "newins ${1} failed"
}


#****I* Installing/doicon
#  SYNOPSIS
#  doicon FILE [FILE] ...
#  DESCRIPTION
#  Installs the given image file(s) into the legacy icon directory under $D.
#  NOTES
#  * Supported icon formats are PNG, XPM, and SVG.
#  * This location is intended for packages shipping a single icon.  If the
#    same PNG icon is available in different sizes, with or without a
#    corresponding SVG, then these icons should be installed into
#    the Hicolor Icon Theme hierarchy.
#****
doicon() {
	local _insinto_tmp=${_insinto_dir}

	insinto /usr/share/pixmaps
	doins ${@}

	_insinto_dir=${_insinto_tmp}
}

#****I* Installing/newicon
#  SYNOPSIS
#  newicon FILE NEW_NAME
#  DESCRIPTION
#  Installs the given image file into the legacy icon directory under $D,
#  renaming it as indicated.
#  NOTE
#  Supported icon formats are PNG, XPM, and SVG.
#****
newicon() {
	local _insinto_tmp=${_insinto_dir}

	insinto /usr/share/pixmaps
	newins ${1} ${2}

	_insinto_dir=${_insinto_tmp}
}

#****I* Installing/dolib
#  SYNOPSIS
#  dolib LIBRARY [LIBRARY] ...
#  DESCRIPTION
#  Installs the given libtool, static, or import libraries into $D/usr/lib/.
#  NOTE
#  Library DLLs must be installed with dobin.
#****
dolib() {
	dodir /usr/lib
	for i
	do
		case ${i} in
			*.la) __doinstall 0755 ${i} /usr/lib || error "dolib ${i} failed" ;;
			*)    __doinstall 0644 ${i} /usr/lib || error "dolib ${i} failed" ;;
		esac
	done
}

#****I* Installing/doman
#  SYNOPSIS
#  doman [[-l |--lang=]LANGUAGE] MANPAGE [MANPAGE] ...
#  DESCRIPTION
#  Installs the given manpage(s) into the appropriate subdirectory of
#  $D/usr/share/man/.  Localized manpages can be installed by specifing
#  the --lang (-l) argument, otherwise manpages are assumed to be in English.
#****
doman() {
	local manroot=/usr/share/man
	local mandir=${manroot}

	for i
	do
		if defined _doman_next_arg_is_lang
		then
			case ${i} in
				C)	mandir=${manroot} ;;
				*)	mandir="${mandir}/${i}" ;;
			esac
			unset _doman_next_arg_is_lang
			continue
		fi

		case ${i} in
			--lang=*)
				case ${i#*=} in
					C)	mandir=${manroot} ;;
					*)	mandir="${mandir}/${i#*=}" ;;
				esac
				continue
			;;
			-l)
				_doman_next_arg_is_lang=1
				continue
			;;			
			*.1|*.1m|*.1x|*.1.bz2|*.1.gz)  mansection=1 ;;
			*.3|*.3pm|*.3t|*.3.gz)  mansection=3 ;;
			*.4|*.4.gz)  mansection=4 ;;
			*.5|*.5.gz)  mansection=5 ;;
			*.6|*.6x|*.6.gz)  mansection=6 ;;
			*.7|*.7.gz)  mansection=7 ;;
			*.8|*.8.gz)  mansection=8 ;;
			*.n|*.n.gz)  mansection=n ;;
			*)  error "unknown man section" ;;
		esac

		dodir ${mandir}/man${mansection}
		__doinstall 0644 ${i} ${mandir}/man${mansection} || error "doman ${i} failed"
	done
}

#****I* Installing/newman
#  SYNOPSIS
#  newman [[-l |--lang=]LANGUAGE] MANPAGE NEW_NAME
#  DESCRIPTION
#  Installs the given manpage into the appropriate subdirectory of
#  $D/usr/share/man/ with the given new name.  Localized manpages can be
#  installed by specifing the --lang (-l) argument, otherwise manpages are
#  assumed to be in English.
#****
newman() {
	local manroot=/usr/share/man
	local mandir=${manroot}

	case ${1} in
		--lang=*)
			case ${1#*=} in
				C)	mandir=${manroot} ;;
				*)	mandir="${mandir}/${1#*=}" ;;
			esac
			shift
		;;
		-l)
			case ${2} in
				C)	mandir=${manroot} ;;
				*)	mandir="${mandir}/${2}" ;;
			esac
			shift 2
		;;
	esac

	case ${2} in
		*.1|*.1m|*.1x|*.1.bz2|*.1.gz)  mansection=1 ;;
		*.3|*.3pm|*.3t|*.3.gz)  mansection=3 ;;
		*.4|*.4.gz)  mansection=4 ;;
		*.5|*.5.gz)  mansection=5 ;;
		*.6|*.6x|*.6.gz)  mansection=6 ;;
		*.7|*.7.gz)  mansection=7 ;;
		*.8|*.8.gz)  mansection=8 ;;
		*.n|*.n.gz)  mansection=n ;;
		*)  error "unknown man section" ;;
	esac

	dodir ${mandir}/man${mansection}
	__doinstall 0644 ${1} ${mandir}/man${mansection} ${2} || error "doman ${1} failed"
}

#****I* Installing/domenu
#  SYNOPSIS
#  domenu DESKTOP_MENU [DESKTOP_MENU] ...
#  DESCRIPTION
#  Installs the given desktop menu entries (.desktop).
#****
domenu() {
	local _insinto_tmp=${_insinto_dir}

	insinto /usr/share/applications
	doins ${@}

	_insinto_dir=${_insinto_tmp}
}

#****I* Installing/newmenu
#  SYNOPSIS
#  newmenu DESKTOP_MENU NEW_NAME
#  DESCRIPTION
#  Installs the given desktop menu entry (.desktop) with the given new name.
#****
newmenu() {
	local _insinto_tmp=${_insinto_dir}

	insinto /usr/share/applications
	newins ${1} ${2}

	_insinto_dir=${_insinto_tmp}
}

#****I* Installing/dosbin
#  SYNOPSIS
#  dosbin FILE [FILE] ...
#  DESCRIPTION
#  Installs the given file(s) to $D/usr/sbin/ and makes them executable.
#****
dosbin() {
	local _exeinto_tmp=${_exeinto_dir}

	exeinto /usr/sbin
	doexe ${@}

	_exeinto_dir=${_exeinto_tmp}
}

#****I* Installing/newsbin
#  SYNOPSIS
#  newsbin FILE NEW_NAME
#  DESCRIPTION
#  Installs the given file to $D/usr/sbin/ with the given new name, and makes
#  it executable.
#****
newsbin() {
	local _exeinto_tmp=${_exeinto_dir}

	exeinto /usr/sbin
	newexe ${1} ${2}

	_exeinto_dir=${_exeinto_tmp}
}


#****I* Installing/dosym
#  SYNOPSIS
#  dosym TARGET [TARGET] ... DESTINATION
#  DESCRIPTION
#  Creates symlinks from the given target(s) to the given destination.  The
#  destination must be a directory if more than one target is given).  Both
#  relative and absolute targets are supported; relative targets must be given
#  in relation to the destination.
#  NOTE
#  The destination directory must exist under $D before dosym is called,
#  therefore a preceding call to dodir may be necessary.
#****
dosym() {
	local _argv=("dosym" ${@})
	local _argc=$#

	if ((_argc < 2))
	then
		error "dosym: requires at least two arguments"
	fi

	dest="${_argv[${_argc}]}"

	# cd should allow for relative symlinks
	# e.g. dosym ../share/foo /usr/lib/
	if [ -d ${D}${dest} ]
	then
		pushd ${D}${dest}
	elif [ -d ${D}${dest%/*} ]
	then
		pushd ${D}${dest%/*}
	else
		error "dosym: ${dest%/*} is not a directory"
	fi

	ln -sf ${_argv[*]:1:$((_argc - 1))} ${D}${dest} || error "dosym failed"

	popd
}


#****I* Installing/make_desktop_entry
#  SYNOPSIS
#  make_desktop_entry COMMAND NAME ICON CATEGORIES [COMMENT] [ADDITIONAL_FIELDS]
#  DESCRIPTION
#  Creates a desktop menu entry for GUI applications as follows:
#  * COMMAND: the command line.  May contain arguments, in which case the
#    entire command must be quoted.
#  * NAME: the application name to be shown in the menu.
#  * ICON: the icon name, excluding the file extension.
#  * CATEGORIES: a colon-separated list of categories and subcategories per
#    |html the <a href="http://standards.freedesktop.org/menu-spec/latest/apa.html">Desktop Menu Specification</a>.
#  * COMMENT: (optional) description of the program
#  * ADDITIONAL_FIELDS: (optional) up to four additional menu entry fields per
#    |html the <a href="http://standards.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#recognized-keys">Desktop Entry Specification</a>.
#****
make_desktop_entry() {
	if (( $# < 2 ))
	then
		error "make_desktop_entry requires a minimum of two arguments"
	fi

	dodir /usr/share/applications

	cat > ${D}/usr/share/applications/${1%% *}.desktop <<-_EOF
		[Desktop Entry]
		Encoding=UTF-8
		Version=1.0
		Name=${2}
		Type=Application
		Comment=${5}
		Exec=${1}
		TryExec=${1%% *}
		Icon=${3}
		Categories=${4};
		${6}
		${7}
		${8}
		${9}
	_EOF
}

#****I* Installing/make_etc_defaults
#  SYNOPSIS
#  make_etc_defaults FILE_PATH [FILE_PATH] ...
#  DESCRIPTION
#  Indicates that the given file(s) under $D are templates for system-configurable
#  files.  make_etc_defaults moves these files to a special location, creates
#  a postinstall script to install the file to the correct location if it doesn't
#  already exist, and a preremove script which removes the file if still unchanged.
#****
make_etc_defaults() {
	for etc in ${@}
	do
		if [ ! -f ${D}${etc} ]
		then
			error "file ${etc} does not exist"
		fi

		dodir /etc/defaults${etc%/*}
		mv ${D}${etc} ${D}/etc/defaults${etc}

		dodir /etc/postinstall
		cat >> ${D}/etc/postinstall/${PN}.sh <<-_EOF
			if [ ! -f ${etc} ]
			then
			    /usr/bin/mkdir -p ${etc%/*}
			    /usr/bin/cp /etc/defaults${etc} ${etc}
			fi

		_EOF

		dodir /etc/preremove
		cat >> ${D}/etc/preremove/${PN}.sh <<-_EOF
			if [ -f ${etc} ] && cmp -s /etc/defaults${etc} ${etc}
			then
			    rm ${etc}
			fi

		_EOF
	done
}

__prepinstalldirs() {
	rm -fr ${D}/*;
}

#****I* Installing/cyginstall
#  SYNOPSIS
#  cyginstall [OPTIONS]
#  DESCRIPTION
#  Runs 'make install' (or 'make install/fast' in CMake packages) with the
#  necessary arguments to install into $D, based on the value of USE_DESTDIR.
#****
cyginstall() {
	if $(make -n -s install/fast &> /dev/null)
	then
		inst_target="install/fast"
	else
		inst_target="install"
	fi

#****v* cyginstall/USE_DESTDIR
#  DESCRIPTION
#  Set to 1 (the default) if 'make install' supports the DESTDIR variable, or
#  0 if not, in which case the value of prefix and the standard *dir variables
#  will be overriden with $D-prefixed values.
#****
	case ${USE_DESTDIR:-1} in
		1|[Yy]|[Yy][Ee][Ss]|[Oo][Nn]|[Tt][Rr][Uu][Ee])
			make ${MAKEOPTS} ${inst_target} DESTDIR=${D} "${@}" || error "make install DESTDIR failed"
			;;
		0|[Nn]|[Nn][Oo]|[Oo][Ff][Ff]|[Ff][Aa][Ll][Ss][Ee])
			make ${MAKEOPTS} install \
				prefix=${D}/usr \
				exec_prefix=${D}/usr \
				bindir=${D}/usr/bin/ \
				includedir=${D}/usr/include \
				libdir=${D}/usr/lib \
				sbindir=${D}/usr/sbin \
				libexecdir=${D}/usr/lib \
				datadir=${D}/usr/share \
				infodir=${D}/usr/share/info \
				mandir=${D}/usr/share/man \
				localstatedir=${D}/var \
				sysconfdir=${D}/etc \
				"${@}" \
				|| error "make install No-DESTDIR failed"
			;;
		*)
			error "USE_DESTDIR should be set to either 0 or 1 (default).";
			;;
	esac
}

#****I* Installing/src_install
#  DESCRIPTION
#  This function must be defined in the .cygport file, or in inherit()ed
#  cygclasses, containing all steps necessary to install the package into
#  $D and prepare it for packaging.
#
#  The default src_install function is shown below.  Several cygclasses
#  provide their own src_install overrides.
#  DEFINITION
src_install() {
	cd ${B}
	cyginstall
}
#****

# protect functions
readonly -f __doinstall dodir keepdir dobin newbin docinto dodoc newdoc \
            exeinto doexe newexe insinto doins newins doicon newicon \
            dolib doman newman domenu newmenu dosbin newsbin dosym \
            make_desktop_entry make_etc_defaults __prepinstalldirs cyginstall
